#!KAMAILIO
#!define WITH_MYSQL
#!define WITH_XHTTP
#!define WITH_XHTTP_RPC
#!define WITH_LB
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_DLG
#!define WITH_PSTN
#!define WITH_MULTIDOMAIN
#!define QU 0
#
# Kamailio (OpenSER) SIP Server v5.0 - default configuration script
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode:
#     - define WITH_DEBUG
#
# *** To enable mysql:
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable the embedded http server:
#     - define WITH_XHTTP
#
# *** To enable the RPC web interface execute:
#     - enable xhttp
#     - define WITH_XHTTP_RPC
#
# *** To enable the provisioning web interface execute:
#     - enable mysql
#     - enable xhttp
#     - define WITH_XHTTP_PI
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To enable VoiceMail routing execute:
#     - define WITH_VOICEMAIL
#     - set the value of voicemail.srv_ip
#     - adjust the value of voicemail.srv_port
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://kamailio:kamailiorw@localhost/kamailio"
#!endif
#!endif
#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
#log_facility=LOG_LOCAL0
#log_name="kamailio"
fork=yes
children=5

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
#auto_aliases=yes

/* add local domain aliases */
#alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to 
   bind on a specific interface/port/proto (default bind on all available) */
#listen=udp:10.66.193.102:5090
#listen=udp:10.66.193.103:5060
listen=udp:192.168.15.213:5060
#listen=tcp:10.66.193.100:5060
#listen=tcp:10.66.193.101:5060
#listen=tcp:192.168.15.45:5060

/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=5060
port=5090
port=6060
mhomed=yes
#!ifdef WITH_TLS
enable_tls=yes
#!endif

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605

#!ifdef WITH_XHTTP
tcp_accept_no_cl=yes
#!endif

####### Custom Parameters #########

# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#

#!ifdef WITH_PSTN
# PSTN GW Routing
#
# - pstn.gw_ip: valid IP or hostname as string value, example:
# pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
#
# - by default is empty to avoid misrouting
pstn.gw_ip = "192.168.15.215" desc "PSTN GW Address"
pstn.gw_port = "5090" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
# VoiceMail Routing on offline, busy or no answer
#
# - by default Voicemail server IP is empty to avoid misrouting
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "5060" desc "VoiceMail Port"
#!endif

####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath="modules"
#!else
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "sqlops.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_XHTTP
loadmodule "xhttp.so"
#!endif

#!ifdef WITH_XHTTP_RPC
loadmodule "xhttp_rpc.so"
#!endif

#!ifdef WITH_XHTTP_PI
loadmodule "xhttp_pi.so"
#!endif

#!ifdef WITH_DLG
loadmodule "dialog.so"
#!endif

#!ifdef WITH_LB
loadmodule "dispatcher.so"
#!endif

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
modparam("jsonrpcs", "transport", 0)
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")
modparam("jsonrpcs", "dgram_socket", "tcp:192.168.15.213:8090")


# ----- ctl params -----
#modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")


# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)


# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)


# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)


# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", 
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif


# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif


# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif

#!endif


# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif


# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif


# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 1)
#!endif


#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif


#!ifdef WITH_NAT
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif


#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/usr/local/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
#modparam("debugger", "log_facility", "LOG_LOCAL0")
#modparam("debugger", "log_prefix", "from-debugger-with-love:")
#!endif
#modparam("xlog", "buf_size", 8192)
#modparam("xlog", "log_facility", "LOG_LOCAL0")
#modparam("xlog", "log_facility", "LOG_DAEMON")
#!ifdef WITH_XHTTP_RPC
modparam("xhttp_rpc", "xhttp_rpc_root", "http_rpc")
#!endif

#!ifdef WITH_XHTTP_PI
modparam("xhttp_pi", "xhttp_pi_root", "http_pi")
modparam("xhttp_pi", "framework", "/usr/local/etc/kamailio/pi_framework.xml")
#!endif

#!ifdef WITH_LB
#modparam("dispatcher", "db_url", DBURL)
#modparam("dispatcher", "ds_ping_method", "OPTIONS")
#modparam("dispatcher", "ds_probing_mode", 1)
#modparam("dispatcher", "ds_ping_interval", 5)
#modparam("dispatcher", "flags", 3)
#modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=403;code=404;code=484;class=3")
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "force_dst", 1)
modparam("dispatcher", "flags", 3)
modparam("dispatcher", "ds_ping_from", "sip:proxy@192.168.15.213")
modparam("dispatcher", "ds_ping_interval",30)
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=403;code=404;code=484;class=3")


#!endif

#!ifdef WITH_DLG
modparam("dialog", "default_timeout", 21600)
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "profiles_with_value", "calls")
#!endif

####### Routing Logic ########
modparam("sqlops","sqlcon", "cb=>mysql://vicky:1234@192.168.15.212/kamailio")
modparam("sqlops", "sqlres", "ra")
# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {

#       xlog("L_NOTICE", "Xlog working");
 	# per request initial checks
	route(REQINIT);

	xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): --- New '$rm' Message Pocessing Started ---\n");
	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans())
			t_relay();
                   #$var(tot)=100;
                   xlog("L_NOTICE", "Xlog Cancellllllllllllllllllllllllllllllllllll  $si");
                   #sql_query("cb", "select * from calls","ra");
		   #xlog("L_NOTICE","Xlogggggggggggggggggggggg $dbr(ra=>[0,2]) ");
                      # set_dlg_profile("calls","Total");
                      # get_profile_size("calls","Total","$var(total)");
                      # $var(total)=$var(total)-1;
                   if(is_present_hf("N-Billable"))
                   { xlog("L_NOTICE", "queue flag is here");}
                  sql_query("cb", "update calls set total2=total2-1 where id='1'");
                   #sql_query("cb", "update calls set total2=$dbr(ra=>[0,2])-2 where id='1'");
             #   sql_result_free("ra"); 
                sql_query("cb","select c_type,client_id,customer from csp where (extension='$fU' and customer='$tU') or(extension='$tU' and customer='$fU')","ra");
                xlog("L_INFO","here is dbr ra client id $dbr(ra=>[0,1]) and channel type is $dbr(ra=>[0,0]) and tU is $tU and fU is $fU" );
                #sql_query("cb","update dial_list_acl set stat='NULL', customer='NULL',c_type='NULL' where extension='$fU' or extension='$tU' or customer='$tU'");
                #sql_query("cb","delete from csp where extension='$fU' or extension='$tU' or customer='$tU'"); 
               # sql_query("cb","select c_type,client_id from dial_list_acl","ra");
                if($dbr(ra=>[0,0])=='incoming')
                {
                sql_query("cb","delete from csp where extension='$fU' and customer='$tU'");
                sql_query("cb","delete from csp where extension='$tU' and customer='$fU'");
                sql_query("cb","UPDATE clients SET incoming_ch=(Select COUNT('incoming') FROM csp WHERE c_type='incoming' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
               if($dbr(ra=>[0,0])=='outgoing') 
               {
                sql_query("cb","delete from csp where extension='$fU' and customer='$tU'");
                sql_query("cb","delete from csp where extension='$tU' and customer='$fU'");
              sql_query("cb","UPDATE clients SET outgoing_ch=(Select COUNT('outgoing') FROM csp WHERE c_type='outgoing' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
               if($dbr(ra=>[0,0])=='ext2ext' or $dbr(ra=>[0,0])=='ext2extincoming')
               {
                 xlog("L_NOTICE", "Xlog Cancellllllllllllllllllllllllllllllllllll  tU is $tU and fU is $fU");
                 sql_query("cb","delete from csp where extension='$fU' and customer='$tU'");
                sql_query("cb","delete from csp where extension='$tU' and customer='$fU'");
              sql_query("cb","UPDATE clients SET exten_ch=(Select COUNT('ext2ext') FROM csp WHERE c_type='ext2ext' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}     
                sql_result_free("ra");
             exit;
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# handle retransmissions
	if(t_precheck_trans()) {
		t_check_trans();
		exit;
	}
	t_check_trans();

	# authentication
	route(AUTH);

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE"))
		record_route();

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(4);
		setflag(FLT_ACC); # do accounting
                set_dlg_profile("calls","Total");
                get_profile_size("calls","Total","$var(total)");
                #$var(total)=$var(total)+1;
                #$var(k1)=0;
                #$var(k2)=1;
                $var(totalcalls)=0;
                xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): Current Active Total Channels: $var(total)\n");
                sql_query("cb", "update calls set total2=$var(total) where id='1'");
                sql_query("cb","select * from calls","ra");
                xlog("L_INFO","number of channels are k2 $dbr(ra=>[0,1]), k1 $dbr(ra=>[0,2]) \n");
                xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): Current Active Total Channels: $var(total)\n");
                $var(k1)=$dbr(ra=>[0,1]);
                $var(k2)=$dbr(ra=>[0,2]);
                $var(totalcalls)=$(var(k1){s.int}) + $(var(k2){s.int}); 
                xlog("L_INFO","Total number of channels are $var(totalcalls) and received invite from $fU to $tU\n");
		#Change Channel Limit Here
		if($var(totalcalls) > 4) {
			xlog("L_WARN", "[$fU|$tU](SENDER[$si:$sp]): REJECTING CALL - Exceeding Allowed Calls Limit of 2 channels: $var(totalcalls)\n");
			send_reply("503","Service Unavailable");
                        #sql_query("cb", "update calls set total2=$var(total)-1 where id='1'");
			exit;
		}
sql_query("cb","select limit_ch,(incoming_ch+outgoing_ch+exten_ch) as total from clients where id IN (select client_id from dial_list_acl where extension=$fU or customer=$fU or extension=$tU or customer=$tU) or DID=$tU","ra");
xlog("L_INFO","Total calls are $dbr(ra=>[0,1]) and limit is $dbr(ra=>[0,0])");
if($dbr(ra=>[0,1])>$dbr(ra=>[0,0]))
{
    xlog("L_WARN", "[$fU|$tU](SENDER[$si:$sp]): REJECTING CALL - Exceeding Allowed Calls Limit: $dbr(ra=>[0,1])\n");
    send_reply("503","Service Unavailable");
    sql_result_free("ra");
    exit;
}         
sql_result_free("ra");
	}

	# dispatch requests to foreign domains
	route(SIPOUT);

	### requests for my local domains

	# handle presence related requests
	#route(PRESENCE);

	# handle registrations
	route(REGISTRAR);

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484", "Address Incomplete");
		exit;
	}

	# dispatch destinations to PSTN
	route(LB);
	route(PSTN);

	# user location service
	#route(LOCATION);

	route(RELAY);
}


route[RELAY] {

	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
                setflag(13);
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
	if($ua =~ "friendly-scanner") {
		sl_send_reply("200", "OK");
		exit;
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("1511", "7")) {
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}
	t_on_reply("LOG_REPLY");
}
# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;
	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
                        #set_dlg_profile("calls","Total");
                        #get_profile_size("calls","Total","$var(total)");
                        #$var(total)=$var(total)-1;
                        sql_query("cb", "update calls set total2=total2-1 where id='1'");
                        #if(is_present_hf('N-Billable'))
                       # {xlog("L_NOTICE","Flag from asterisk is being received");}
                        #$var(count)=$var(count)+1;
                        sql_query("cb","select COUNT($tU) from clients where DID=$tU","ra");
                        if($dbr(ra=>[0,0])==0)
                        {
                        sql_query("cb","select c_type,client_id,customer from csp where extension='$fU' or customer='$fU' or extension='$tU' or customer='$tU'","ra");
                        xlog("L_INFO","here is dbr ra client id $dbr(ra=>[0,1]) and channel type is $dbr(ra=>[0,0]) and customer is $dbr(ra=>[0,1])" );
                        xlog("L_INFO","Byeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee $fU      |    $tU  |    $ru  | $rd | $sp");
                        sql_query("cb","delete from csp where (extension='$fU' and  customer='$tU') or (extension='$tU' or customer='$fU') ");
                        #sql_query("cb","delete from csp where extension=$tU and  customer=$fU");
               #         sql_query("cb","select c_type,client_id from dial_list_acl","ra");
                       if($dbr(ra=>[0,0])=='incoming')
                       {sql_query("cb","UPDATE clients SET incoming_ch=(Select COUNT('incoming') FROM csp WHERE c_type='incoming'and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                   if($dbr(ra=>[0,0])=='outgoing')
                   {sql_query("cb","UPDATE clients SET outgoing_ch=(Select COUNT('outgoing') FROM csp WHERE c_type='outgoing' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                       # xlog("L_INFO","here is dbr ra client id $dbr(ra=>[0,1]) and channel type is $dbr(ra=>[0,0])" );
                if($dbr(ra=>[0,0])=='ext2ext' or $dbr(ra=>[0,0])=='ext2extincoming')
               {sql_query("cb","UPDATE clients SET exten_ch=(Select COUNT('ext2ext') FROM csp WHERE c_type='ext2ext' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
	}
                        sql_result_free("ra");
}
		else if ( is_method("ACK") ) {
			# ACK is forwarded statelessy
			route(NATMANAGE);
		}
		else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		#route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			t_relay();
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
	sl_send_reply("404", "Not here");
	exit;
}

# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")) return;

	xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(REGISTRAR) We should never be here !! Are we Registering Users?\n");
	if(isflagset(FLT_NATS)) {
		setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
		# do SIP NAT pinging
		setbflag(FLB_NATSIPPING);
#!endif
	}
	if (!save("location"))
		sl_reply_error();

	exit;
}

# User location service
route[LOCATION] {

#!ifdef WITH_SPEEDDIAL
	# search for short dialing - 2-digit extension
	if($rU=~"^[0-9][0-9]$")
		if(sd_lookup("speed_dial"))
			route(SIPOUT);
#!endif

#!ifdef WITH_ALIASDB
	# search in DB-based aliases
	if(alias_db_lookup("dbaliases"))
		route(SIPOUT);
#!endif

	$avp(oexten) = $rU;
	if (!lookup("location")) {
		$var(rc) = $rc;
		route(TOVOICEMAIL);
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}

	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE")) {
		setflag(FLT_ACCMISSED);
	}
}

# Authentication route
route[AUTH] {
	#xlog("L_INFO", "[$fU:$tU]: Authenticating Packet");
#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH
#	xlog("L_NOTICE", "Auth: Incoming request '$rm' from source '$si' to '$Ri'");
	if((!is_method("REGISTER")) && allow_source_address()) {
		# source IP allowed
#		xlog("L_NOTICE", "Auth: Allowed '$rm' from source '$si' to '$Ri'");
		return;
	}
	xlog("L_WARN", "[$fU|$tU](SENDER[$si:$sp]): Route[AUTH] Rejected '$rm' from '$si' to '$Ri'");
	exit;
#!endif

	if (is_method("REGISTER") || from_uri==myself) {
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "1")) {
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}

#!endif
	return;
}

# Caller NAT detection route
route[NATDETECT] {
#!ifdef WITH_NAT
	force_rport();
	if (nat_uac_test("19")) {
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop())
				set_contact_alias();
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# RTPProxy control
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
		return;

	rtpproxy_manage("co");

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}

# Routing to foreign domains
route[SIPOUT] {
	if (uri==myself) return;

	xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(SIPOUT) We should never be here !! Are we sending call out to external domains ?\n");
	append_hf("P-hint: outbound\r\n");
	route(RELAY);
	exit;
}

# Dispatcher LoadBalancing
route[LB] {
#!ifdef WITH_LB
	if($si == $sel(cfg_get.pstn.gw_ip)) {
                #setflag(4);
                #setflag(FLT_ACC); # do accounting
                set_dlg_profile("calls","TotalCalls");
                get_profile_size("calls","TotalCalls","$var(calls)");
                #$var(calls)=$var(calls)+'1';
                $var(x)=$tU;
		xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(LOADBALANCER) Call From ZONG GW || Total Calls Count: $var(calls)        $(tU{s.len})\n");
                if($(tU{s.len})==6 or $(tU{s.len})==7)
                {
                sql_query("cb", "update calls set total2=total2+1 where id='1'");
                xlog("L_INFO","length of $fU  is $(fU{s.len})");
                sql_query("cb","select client_id from dial_list where extension=$fU","ra");
                sql_query("cb", "insert into csp(extension,customer,c_type,client_id)values('$fU','$tU','ext2ext','$dbr(ra=>[0,0])')");
                #sql_query("cb","select c_type,client_id from dial_list_acl where extension=$fU","ra");
                sql_query("cb","UPDATE clients SET exten_ch=(Select COUNT('ext2ext') FROM csp WHERE c_type='ext2ext' and client_id=$dbr(ra=>[0,0])) WHERE id=$dbr(ra=>[0,0])");
                }
                if($(var(x){s.striptail,9})=='7703')
                {
                sql_query("cb", "update calls set total2=total2+1 where id='1'"); 
                xlog("L_INFO","Substringggggg $(var(x){s.striptail,9})  and $fU  and $(fU{s.len})");
                 sql_query("cb","select client_id from dial_list where extension=$fU","ra");
                sql_query("cb", "insert into csp(extension,customer,c_type,client_id)values('$fU','$tU','outgoing','$dbr(ra=>[0,0])')");
                #sql_query("cb", "update dial_list_acl set customer='$tU',c_type='outgoing' where extension=$fU");
                #sql_query("cb","select c_type,client_id from dial_list_acl where extension=$fU","ra");
                sql_query("cb","UPDATE clients SET outgoing_ch=(Select COUNT('outgoing') FROM csp WHERE c_type='outgoing' and client_id=$dbr(ra=>[0,0])) WHERE id=$dbr(ra=>[0,0])");
                }
                force_send_socket(udp:192.168.15.213:5060);
		ds_mark_dst("P");
                sql_query("cb","select c_type,client_id,customer from csp where extension='$fU' or extension='$tU' or customer='$tU' or customer='77$tU'","ra");
		# Enter debug MSISDN here.
		#if( $fU == "3212751275" || $tU == "3212751275" || $fU == "3154494444" || $tU == "3154494444") {
		if(  $fU == "3125690936" || $tU == "3125690936" ||  $fU == "3324908271" ||  $tU == "3324908271" ||  $fU == "3125690936" || $fU=="3164047858" || $tU=="3164047858" ) {
			xlog("L_NOTICE", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(LOADBALANCER) DEBUG Call Sending to Asterisk-Group:3\n");
			if ( !ds_select_dst("3","4") ) {
				xlog("L_ERR","[$fU|$tU](SENDER[$si:$sp]): ROUTE(LOADBALANCER) All application servers down?");
                                 sql_query("cb","delete from csp where (extension=$fU and (customer=$tU or customer='77$tU')) or (customer=$fU and extension=$tU)");
                             if($dbr(ra=>[0,0])=='incoming')
                             {sql_query("cb","UPDATE clients SET incoming_ch=(Select COUNT('incoming') FROM csp WHERE c_type='incoming' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                             if($dbr(ra=>[0,0])=='outgoing')
                             {sql_query("cb","UPDATE clients SET outgoing_ch=(Select COUNT('outgoing') FROM csp WHERE c_type='outgoing' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                             if($dbr(ra=>[0,0])=='ext2ext' or $dbr(ra=>[0,0])=='ext2extincoming')
                             {sql_query("cb","UPDATE clients SET exten_ch=(Select COUNT('ext2ext') FROM csp WHERE c_type='ext2ext' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                                 xlog("L_INFO","here is dbr ra is being freed and conditional flag 15 is not set");
                                 sql_query("cb", "update calls set total2=total2-1 where id='1'");
				send_reply("500","No Destination available");
                                exit;
			}
		} else {
			if ( !ds_select_dst("1","4") ) {
				xlog("L_ERR", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(LOADBALANCER) All application servers down?");
                                sql_query("cb","delete from csp where (extension=$fU and (customer=$tU or customer='77$tU')) or (customer=$fU and extension=$tU)");
                              if($dbr(ra=>[0,0])=='incoming')
                             {sql_query("cb","UPDATE clients SET incoming_ch=(Select COUNT('incoming') FROM csp WHERE c_type='incoming' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                             if($dbr(ra=>[0,0])=='outgoing')
                             {sql_query("cb","UPDATE clients SET outgoing_ch=(Select COUNT('outgoing') FROM csp WHERE c_type='outgoing' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                             if($dbr(ra=>[0,0])=='ext2ext' or $dbr(ra=>[0,0])=='ext2extincoming')
                             {sql_query("cb","UPDATE clients SET exten_ch=(Select COUNT('ext2ext') FROM csp WHERE c_type='ext2ext' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");}
                              xlog("L_INFO","here is dbr ra is being freed and conditional flag 15 is not set");
                             sql_query("cb", "update calls set total2=total2-1 where id='1'");
				send_reply("500","No Destination available");
				exit;
			}
		}
	} else {
                
		return;
	}
	xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(LOADBALANCER) Sending to Destination Media-Server '$du'");
	route(RELAY);
	exit;
#!endif
}

# PSTN GW routing
route[PSTN] {
#!ifdef WITH_PSTN
	xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(PSTN) Possibly Asterisk Box Sending Call for PSTN Destination:$tU\n"); 
	# check if PSTN GW IP is defined
	if (strempty($sel(cfg_get.pstn.gw_ip))) {
		xlog("SCRIPT: PSTN rotuing enabled but pstn.gw_ip not defined\n");
		return;
	}

	# route to PSTN dialed numbers starting with '+' or '00'
	#     (international format)
	# - update the condition to match your dialing rules for PSTN routing
	#if(!($rU=~"^(03)[0-9]{9}$"))
	#	xlog("L_ERR", "[$fU:$tU](Outbound): Number format '$rU' incorrect. Correct format is 03XXXXXXXXX");
	#	xlog("IN PSTN");
	#	return;

	$var(req) = $(rU{s.substr,1,0});
	$rU = $var(req);

	if(is_present_hf("X-Billable")) {
         #	setflag(4);
               # setflag(FLT_ACC); # do accounting
		force_send_socket(udp:192.168.15.213:5060);
                set_dlg_profile("calls","Billable");
                get_profile_size("calls","Billable","$var(calls)");
                #$var(calls)=$var(calls)+'1';
		xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(PSTN) Billable Call from Asterisk - Current Billable Calls Count:$var(calls)");
                xlog("L_INFO","Hi I am Kamailigogggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg $var(calls)");
                sql_query("cb", "update calls set total2=total2+1 where id='1'");
	} else if(is_present_hf("N-Billable")){
          #      setflag(4);
           #     setflag(FLT_ACC); # do accounting
		force_send_socket(udp:192.168.15.213:5060);
                set_dlg_profile("calls","N-Billable");
                get_profile_size("calls","N-Billable","$var(calls)");
		xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(PSTN) NON-Billable Call from Asterisk - Current NON-Billable Calls Count:$var(calls)");
                sql_query("cb", "update calls set total2=total2+1 where id='1'");
                sql_query("cb","select client_id from dial_list where extension=$tU","ra");
                sql_query("cb", "insert into csp(extension,customer,c_type,client_id)values('$tU','$fU','ext2extincoming','$dbr(ra=>[0,0])')");
                sql_query("cb","update csp set customer='$tU' where extension=$fU");
	}
	else{
            #    setflag(4);
             #   setflag(FLT_ACC); # do accounting
                force_send_socket(udp:192.168.15.213:5060);
                set_dlg_profile("calls","Inbound");
                get_profile_size("calls","Inbound","$var(calls)");
                xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(PSTN) NON-Billable Inbound Call from Asterisk - Current NON-Billable Inbound Calls Count:$var(calls) and tU is $tU");

                sql_query("cb","select client_id from dial_list where extension=$tU or extension=$fU","ra");
                sql_query("cb","insert into csp(extension,customer,c_type,client_id)values('$tU','$fU','incoming',$dbr(ra=>[0,0]))");
               # sql_query("cb", "update dial_list_acl set customer='$fU',c_type='incoming' where extension='$tU'");
                sql_query("cb","UPDATE clients SET incoming_ch=(Select COUNT('incoming') FROM csp WHERE c_type='incoming' and client_id=$dbr(ra=>[0,0])) WHERE id=$dbr(ra=>[0,0])");
                xlog("L_INFO","RA's value is $dbr(ra=>[0,0])");
                sql_result_free("ra");
                sql_query("cb", "update calls set total2=total2+1 where id='1'");
	}		

	if(is_present_hf("IsQueueCall")){
		setflag(26);
		xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(PSTN) Setting Queue Call Flag");
                if (isflagset(26))
                { xlog("L_INFO","My queue flag is set and queueu is QU and tu is $tU");}
               # set_dlg_profile("calls","Total");
               # get_profile_size("calls","Total","$var(total)");
               #sql_query("cb", "update calls set total2=total2+1 where id='1'");
               #sql_query("cb","select * from calls","ra");
               #xlog("L_INFO","number of channels are k2 $dbr(ra=>[0,1]), k1 $dbr(ra=>[0,2]) \n");
               #sql_result_free("ra");

	}
	
	if (strempty($sel(cfg_get.pstn.gw_port))) {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
	} else {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
					+ $sel(cfg_get.pstn.gw_port);
	}

	route(RELAY);
	exit;
#!endif

	return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
	# allow XMLRPC from localhost
	if ((method=="POST" || method=="GET")
			&& (src_ip==127.0.0.1)) {
		# close connection only for xmlrpclib user agents (there is a bug in
		# xmlrpclib: it waits for EOF before interpreting the response).
		if ($hdr(User-Agent) =~ "xmlrpclib")
			set_reply_close();
		set_reply_no_connect();
		dispatch_rpc();
		exit;
	}
	send_reply("403", "Forbidden");
	exit;
}
#!endif

# Routing to voicemail server
route[TOVOICEMAIL] {
#!ifdef WITH_VOICEMAIL
	if(!is_method("INVITE"))
		return;

	# check if VoiceMail server IP is defined
	if (strempty($sel(cfg_get.voicemail.srv_ip))) {
		xlog("SCRIPT: VoiceMail rotuing enabled but IP not defined\n");
		return;
	}
	if($avp(oexten)==$null)
		return;

	$ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	route(RELAY);
	exit;
#!endif

	return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

onreply_route[LOG_REPLY] {
	xlog("L_INFO", "[$fU:$tU](Reply): Recieved status code $rs:$rr for method '$rm' from '$fu' to '$tu'"); 
		if($rs == 183) {
			if(is_present_hf("Reason")) {
				xlog("L_INFO", "[$fU|$tU](SENDER[$si:$sp]): ROUTE(PSTN) Checking Queue Call Flag To Disconnect Call Abruptly");
				if(isflagset(26)){
			xlog("L_INFO", "[$fU:$tU](Reply): Cancelling call due to: %@hf_value.Reason.text");
			t_cancel_branches("all");
				}			
			}

		}
  else if($rs==486 or $rs==480)
  {
  sql_query("cb","select c_type,client_id,customer from csp where extension='$fU' or extension='$tU' or customer='$tU' or customer='77$tU'","ra");
  #sql_query("cb","update dial_list_acl set stat='NULL', customer='NULL',c_type='NULL' where extension='$fU' or extension='$tU' or customer='$tU' or customer='77$tU'");
  sql_query("cb","delete from csp where (extension=$fU and (customer=$tU or customer='77$tU')) or (customer=$fU and extension=$tU)");
  if($dbr(ra=>[0,0])=='incoming')
  {
  if(!isflagset(26))
  {sql_query("cb", "update calls set total2=total2-1 where id='1'");}
  sql_query("cb","UPDATE clients SET incoming_ch=(Select COUNT('incoming') FROM csp WHERE c_type='incoming' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");
  xlog("L_INFO","here is dbr ra is being freed and conditional flag 15 is not set");
  sql_query("cb", "update calls set total2=total2-1 where id='1'");
  sql_result_free("ra");
  }
  else if($dbr(ra=>[0,0])=='outgoing')
  {
  if(!isflagset(26))
  {sql_query("cb", "update calls set total2=total2-1 where id='1'");}
   sql_query("cb","UPDATE clients SET outgoing_ch=(Select COUNT('outgoing') FROM csp WHERE c_type='outgoing' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");
  sql_result_free("ra");
  #sql_query("cb", "update calls set total2=total2-1 where id='1'");
  }
  else if($dbr(ra=>[0,0])=='ext2ext' or $dbr(ra=>[0,0])=='ext2extincoming')
  {
   if(!isflagset(26))
  {sql_query("cb", "update calls set total2=total2-1 where id='1'");}
   sql_query("cb","UPDATE clients SET exten_ch=(Select COUNT('ext2ext') FROM csp WHERE c_type='ext2ext' and client_id=$dbr(ra=>[0,1])) WHERE id=$dbr(ra=>[0,1])");
   sql_result_free("ra");
   #sql_query("cb", "update calls set total2=total2-1 where id='1'");

  }
 }

                 else if (($rs==180 or $rs==200) && ($rr=='Ringing' or $rr=='OK') && $rm=='INVITE')
                 {
                   if ($rr=='OK')
                   {
                    sql_query("cb","select COUNT($tU) from clients where DID=$tU","ra");
                    if($dbr(ra=>[0,0])==1)
                    {sql_query("cb", "update calls set total2=total2+1 where id='1'");}
                    sql_query("cb","update csp set stat='ANSWERED' where extension='$tU' and customer='$fU'");
                    sql_query("cb","update csp set stat='ANSWERED' where extension='$fU' and customer='$tU'"); 
                   }
                  else{
                  sql_query("cb","update csp set stat='$rr' where extension='$tU' and customer='$fU'");
                  sql_query("cb","update csp set stat='$rr' where extension='$fU' and customer='$tU'");
                  #xlog("L_INFO","Heyy fu is $fU and tu is $tU");
                  #sql_query("cb","update csp set stat=$rr where (extension='$fU' and (customer='$tU' or customer='77$tU'")));
                }
                }
         

}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE);

	if (t_is_canceled()) {
		exit;
	}

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_VOICEMAIL
	# serial forking
	# - route to voicemail on busy or no answer (timeout)
	if (t_check_status("486|408")) {
		route(TOVOICEMAIL);
		exit;
	}
#!endif
}

# Handling HTTP events
#!ifdef WITH_XHTTP
event_route[xhttp:request] {
	if ($hu =~ "^/") {
		#xlog("L_INFO", "SCRIPT: JSON RPC request $hu\n");
		jsonrpc_dispatch();
		return;
	}
#!ifdef WITH_XHTTP_RPC
	$var(xhttp_rpc_root) = $(hu{s.substr,0,9});
	if ($var(xhttp_rpc_root) == "/http_rpc") {
		dispatch_xhttp_rpc();
	}
#!endif
#!ifdef WITH_XHTTP_PI
	$var(xhttp_rpc_root) = $(hu{s.substr,0,8});
	if ($var(xhttp_rpc_root) == "/http_pi") {
		dispatch_xhttp_pi();
	}
#!endif
	xhttp_reply("200", "OK", "text/html",
		"<html><body>Wrong URL $hu</body></html>");
}
#!endif


